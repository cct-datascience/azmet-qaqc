---
title: "Report"
format: 
  html:
    code-fold: true
    toc: true
editor: visual
---

This could be a parameterized report to change the dates for the QA/QC (e.g. for doing legacy data)

```{r}
#| echo: false
#| message: false
#| warning: false
library(targets)
library(tidyverse)
library(fabletools)
library(lubridate)
library(pointblank)
library(arrow)
library(slider)

tar_load(c(
#  fc_sol_rad,
#  daily_test,
#  daily_train,
  db_daily,
  db_hourly,
  needs_qa_daily,
  needs_qa_hourly
))

#TODO: An alternative to collect() is to convert to duckdb and have pointblank work directly on database.  Might be faster?
daily <-
  open_dataset(db_daily) |> 
  filter(datetime > ymd("2021-01-01")) |>
  collect() |> 
  arrange(meta_station_id, desc(datetime))

hourly <-
  open_dataset(db_hourly) |>
  filter(date_datetime > ymd("2021-01-01")) |>
  collect() |> 
  arrange(meta_station_id, desc(date_datetime))
```

# Consistency checks

```{r}
#create action levels for warnings and errors
#TODO add notify level

al <- action_levels(warn_at = 1, stop_at = 0.1)
```

## Daily Data

```{r}
#| column: body-outset
daily |> 
  create_agent(
    tbl_name = "Daily measures",
    label = "Consistency Checks",
    actions = al
  ) |> 
  # Internal consistency checks from 'NWS (1994) TSP 88-21-R2':
  col_vals_gte(temp_air_meanC, vars(dwpt_mean), na_pass = TRUE) |> 
  col_vals_lte(temp_air_minC, vars(temp_air_meanC), na_pass = TRUE) |> 
  col_vals_lte(temp_air_meanC, vars(temp_air_maxC), na_pass = TRUE) |> 
  col_vals_lte(wind_spd_mean_mps, vars(wind_spd_max_mps), na_pass = TRUE) |> 
  col_vals_lte(temp_soil_10cm_meanC, vars(temp_soil_10cm_maxC), na_pass = TRUE) |> 
  col_vals_lte(temp_soil_10cm_minC, vars(temp_soil_10cm_meanC), na_pass = TRUE) |> 
  col_vals_lte(temp_soil_50cm_meanC, vars(temp_soil_50cm_maxC), na_pass = TRUE) |> 
  col_vals_lte(temp_soil_50cm_minC, vars(temp_soil_50cm_meanC), na_pass = TRUE) |>
  col_vals_lte(relative_humidity_mean, vars(relative_humidity_max), na_pass = TRUE) |>
  col_vals_lte(relative_humidity_min, vars(relative_humidity_mean), na_pass = TRUE) |>
  
  #TODO calculate max sol radiation based on date and location and check for that
  # col_vals_lt(sol_rad_total, sol_rad_expected, preconditions = ~calc_sol(date))
  interrogate()
```

## Hourly data

```{r}
#| column: body-outset
hourly |> 
  create_agent(
    tbl_name = "Hourly measures",
    label = "Consistency Checks",
    actions = al
  ) |> 
  # Internal consistency checks from 'NWS (1994) TSP 88-21-R2':
  col_vals_gte(temp_airC, vars(dwpt), na_pass = TRUE) |> 
  col_vals_lte(wind_spd_mps, vars(wind_spd_max_mps), na_pass = TRUE) |> 
  
  # Temporal consistency checks from 'NWS (1994) TSP 88-21-R2':
  col_vals_lt(
    temp_airC_delta,
    19.4, 
    na_pass = TRUE,
    brief = "Expect that |∆`temp_airC`| < 19.4",
    preconditions = function(x) x |> 
      group_by(meta_station_id) |> 
      mutate(temp_airC_delta = abs(temp_airC - lag(temp_airC)),
             .after = temp_airC) |> 
      ungroup()
  ) |> 
  col_vals_lt(
    relative_humidity_delta,
    50,
    na_pass = TRUE,
    brief = "Expect that |∆`relative_humidity`| < 50",
    preconditions = function(x) x |> 
      group_by(meta_station_id) |> 
      mutate(relative_humidity_delta = abs(relative_humidity - lag(relative_humidity)),
             .after = relative_humidity) |> 
      ungroup()
  ) |> 
  col_vals_lt(
    wind_spd_mps_delta,
    10.3,
    na_pass = TRUE,
    brief = "Expect that |∆`wind_spd_mps`| < 10.3",
    preconditions = function(x) x |> 
      group_by(meta_station_id) |> 
      mutate(wind_spd_mps_delta = abs(wind_spd_mps - lag(wind_spd_mps)),
             .after = wind_spd_mps) |> 
      ungroup()
  ) |> 
  
  # Temporal consistency ('persistence') checks:
  col_vals_equal(
    sol_rad_total_14,
    FALSE, #true means < 1 for the past 14 hours
    na_pass = TRUE,
    brief = "Expect that sol_rad_total should not be < 1 for more than 14 hours",
    preconditions = function(x) x |> 
      group_by(meta_station_id) |> 
      mutate(
        sol_rad_total_14 = slider::slide_lgl(
          sol_rad_total, ~all(.x < 1),
          .after = 14, #.after because arrange(desc(datetime))
          .complete = TRUE
        )
      ) |> ungroup()
  ) |> 
  col_vals_equal(
    wind_spd_mps_14,
    FALSE, #true means < 1 for the past 14 hours
    na_pass = TRUE,
    brief = "Expect that wind_spd_mps should not be < 1 for more than 14 hours",
    preconditions = function(x) x |> 
      group_by(meta_station_id) |> 
      mutate(
        wind_spd_mps_14 = slider::slide_lgl(
          wind_spd_mps, ~all(.x < 1),
          .after = 14, #.after because arrange(desc(datetime))
          .complete = TRUE
        )
      ) |> ungroup()
  ) |> 
  col_vals_equal(
    wind_vector_dir_14,
    FALSE, #true means < 1 for the past 14 hours
    na_pass = TRUE,
    brief = "Expect that wind_vector_dir should not be < 1 for more than 14 hours",
    preconditions = function(x) x |> 
      group_by(meta_station_id) |> 
      mutate(
        wind_vector_dir_14 = slider::slide_lgl(
          wind_vector_dir, ~all(.x < 1),
          .after = 14, #.after because arrange(desc(datetime))
          .complete = TRUE
        )
      ) |> ungroup()
  ) |> 
interrogate()
```

# Forecast-based validation

::: callout-warning
WORK IN PROGRESS\
Currently the same seasonal naïve model is fit to every variable and it is not always appropriate.
See model diagnostic plots with `tar_read(resid_daily)`.
:::

Mouse over the "TBL" column symbol to see which variable is associated with each row of the validation table

```{r}
#| column: body-outset
tar_load(fc_daily)
create_agent(
  fc_daily,
  tbl_name = "Daily Measures",
  label = "Forecast-Based Validations",
  actions = al
) |> 
  col_vals_between(
    obs, vars(lower_95), vars(upper_95), segments = vars(varname)
    ) |> 
  interrogate()
```

# Timeseries Plots

```{r}
library(ggdist)
varnames <- tar_read(needs_qa_daily)
daily_long <- daily |> 
  select(datetime, meta_station_name, meta_station_id, all_of(varnames)) |>
  pivot_longer(varnames, names_to = "varname")

daily_list <- daily_long |> group_by(varname) |> group_split()
fc_daily_list <- fc_daily |> group_by(varname) |> group_split()

ts <- daily_list[[6]]
fc <- fc_daily_list[[6]]

make_plot <- function(ts, fc) {
  ylab <- ts$varname |> unique()
  ts |> 
    filter(datetime > today() - weeks(4)) |> 
    ggplot(aes(x = datetime, y = value)) +
    geom_line() +
    geom_point(data = fc, aes(y = fc_mean), color = "red", shape = 1) +
    geom_point(data = fc, aes(y = obs), color = "blue") +
    geom_interval(data = fc, aes(ymin = lower_95, ymax = upper_95, y = fc_mean), alpha = 0.3, color = "red") +
    geom_interval(data = fc, aes(ymin = lower_99, ymax = upper_99, y = fc_mean), alpha = 0.3, color = "red") +
    labs(y = ylab) +
    facet_wrap(~meta_station_id)
}

```

```{r}
purrr::map2(daily_list, fc_daily_list, make_plot)
```
